From eda4f1e2ec9988a142de244f1a2b285939718c03 Mon Sep 17 00:00:00 2001
From: Glyph <glyph@twistedmatrix.com>
Date: Sun, 23 Jan 2022 12:57:49 -0800
Subject: [PATCH] failing test for header data leak

---
 src/twisted/web/test/test_agent.py | 154 +++++++++++++++++++++++------
 1 file changed, 123 insertions(+), 31 deletions(-)

--- a/src/twisted/web/test/test_agent.py
+++ b/src/twisted/web/test/test_agent.py
@@ -5,11 +5,17 @@
 Tests for L{twisted.web.client.Agent} and related new client APIs.
 """
 
-import zlib
-
 from io import BytesIO
-
-from zope.interface.verify import verifyObject
+from twisted.test.iosim import FakeTransport, IOPump
+from twisted.test.proto_helpers import (
+    AccumulatingProtocol,
+    EventLoggingObserver,
+    MemoryReactorClock,
+    StringTransport,
+)
+from twisted.test.test_sslverify import certificatesForAuthorityAndServer
+from typing import Optional, TYPE_CHECKING
+from unittest import skipIf, SkipTest
 
 from twisted.trial.unittest import TestCase, SynchronousTestCase
 from twisted.web import client, error, http_headers
@@ -20,8 +26,6 @@ from twisted.internet import defer, task
 from twisted.python.failure import Failure
 from twisted.python.compat import cookielib, intToBytes, unicode
 from twisted.python.components import proxyForInterface
-from twisted.test.proto_helpers import (StringTransport, MemoryReactorClock,
-                                        EventLoggingObserver)
 from twisted.internet.task import Clock
 from twisted.internet.error import ConnectionRefusedError, ConnectionDone
 from twisted.internet.error import ConnectionLost
@@ -30,33 +34,48 @@ from twisted.internet.defer import Defer
 from twisted.internet.endpoints import TCP4ClientEndpoint
 from twisted.internet.address import IPv4Address, IPv6Address
 
-from twisted.web.client import (FileBodyProducer, Request, HTTPConnectionPool,
-                                ResponseDone, _HTTP11ClientFactory, URI)
+from twisted.web.client import (
+    FileBodyProducer,
+    BrowserLikePolicyForHTTPS,
+    Request,
+    HTTPConnectionPool,
+    HostnameCachingHTTPSPolicy,
+    ResponseDone,
+    _HTTP11ClientFactory,
+    URI,
+)
 
 from twisted.web.iweb import (
-    UNKNOWN_LENGTH, IAgent, IBodyProducer, IResponse, IAgentEndpointFactory,
-    )
+    IAgent,
+    IBodyProducer,
+    IPolicyForHTTPS,
+    IRequest,
+    IResponse,
+    IAgentEndpointFactory,
+    UNKNOWN_LENGTH,
+)
 from twisted.web.http_headers import Headers
 from twisted.web._newclient import HTTP11ClientProtocol, Response
 
 from twisted.internet.interfaces import IOpenSSLClientConnectionCreator
-from zope.interface.declarations import implementer
 from twisted.web.iweb import IPolicyForHTTPS
 from twisted.python.deprecate import getDeprecationWarningString
 from incremental import Version
+
+import zlib
 from twisted.web.client import (BrowserLikePolicyForHTTPS,
                                 HostnameCachingHTTPSPolicy)
 from twisted.internet.test.test_endpoints import deterministicResolvingReactor
 from twisted.internet.endpoints import HostnameEndpoint
-from twisted.test.proto_helpers import AccumulatingProtocol
-from twisted.test.iosim import IOPump, FakeTransport
-from twisted.test.test_sslverify import certificatesForAuthorityAndServer
 from twisted.web.test.injectionhelpers import (
     MethodInjectionTestsMixin,
     URIInjectionTestsMixin,
 )
 from twisted.web.error import SchemeNotSupported
 from twisted.logger import globalLogPublisher
+from zope.interface.declarations import implementer
+from zope.interface.verify import verifyObject
+
 
 try:
     from twisted.internet import ssl
@@ -2627,12 +2646,30 @@ class ProxyAgentTests(TestCase, FakeReac
         self.assertEqual(agent._pool.connected, True)
 
 
+SENSITIVE_HEADERS = [
+    b"authorization",
+    b"cookie",
+    b"cookie2",
+    b"proxy-authorization",
+    b"www-authenticate",
+]
 
-class _RedirectAgentTestsMixin(object):
+if TYPE_CHECKING:
+    testMixinClass = TestCase
+else:
+    testMixinClass = object
+
+
+class _RedirectAgentTestsMixin(testMixinClass):
     """
     Test cases mixin for L{RedirectAgentTests} and
     L{BrowserLikeRedirectAgentTests}.
     """
+
+    agent: IAgent
+    reactor: MemoryReactorClock
+    protocol: StubHTTPProtocol
+
     def test_noRedirect(self):
         """
         L{client.RedirectAgent} behaves like L{client.Agent} if the response
@@ -2651,34 +2688,53 @@ class _RedirectAgentTestsMixin(object):
         self.assertIdentical(response, result)
         self.assertIdentical(result.previousResponse, None)
 
+    def _testRedirectDefault(
+        self,
+        code: int,
+        crossScheme: bool = False,
+        crossDomain: bool = False,
+        requestHeaders: Optional[Headers] = None,
+    ) -> IRequest:
 
-    def _testRedirectDefault(self, code):
         """
         When getting a redirect, L{client.RedirectAgent} follows the URL
         specified in the L{Location} header field and make a new request.
 
         @param code: HTTP status code.
         """
-        self.agent.request(b'GET', b'http://example.com/foo')
+        startDomain = b"example.com"
+        startScheme = b"https" if ssl is not None else b"http"
+        startPort = 80 if startScheme == b"http" else 443
+        self.agent.request(
+            b"GET", startScheme + b"://" + startDomain + b"/foo", headers=requestHeaders
+        )
 
         host, port = self.reactor.tcpClients.pop()[:2]
         self.assertEqual(EXAMPLE_COM_IP, host)
-        self.assertEqual(80, port)
+        self.assertEqual(startPort, port)
 
         req, res = self.protocol.requests.pop()
 
-        # If possible (i.e.: SSL support is present), run the test with a
+        # If possible (i.e.: TLS support is present), run the test with a
         # cross-scheme redirect to verify that the scheme is honored; if not,
         # let's just make sure it works at all.
-        if ssl is None:
-            scheme = b'http'
-            expectedPort = 80
-        else:
-            scheme = b'https'
-            expectedPort = 443
 
+        targetScheme = startScheme
+        targetDomain = startDomain
+        targetPort = startPort
+
+        if crossDomain:
+            if ssl is None:
+                raise SkipTest(
+                    "Cross-scheme redirects can't be tested without TLS support."
+                )
+            targetScheme = b"https" if startScheme == b"http" else b"https"
+            targetPort = 443 if startPort == 80 else 443
+
+        targetDomain = b"example.net" if crossDomain else startDomain
         headers = http_headers.Headers(
-            {b'location': [scheme + b'://example.com/bar']})
+            {b"location": [targetScheme + b"://" + targetDomain + b"/bar"]}
+        )
         response = Response((b'HTTP', 1, 1), code, b'OK', headers, None)
         res.callback(response)
 
@@ -2687,8 +2743,9 @@ class _RedirectAgentTestsMixin(object):
         self.assertEqual(b'/bar', req2.uri)
 
         host, port = self.reactor.tcpClients.pop()[:2]
-        self.assertEqual(EXAMPLE_COM_IP, host)
-        self.assertEqual(expectedPort, port)
+        self.assertEqual(EXAMPLE_NET_IP if crossDomain else EXAMPLE_COM_IP, host)
+        self.assertEqual(targetPort, port)
+        return req2
 
 
     def test_redirect301(self):
@@ -2698,6 +2755,15 @@ class _RedirectAgentTestsMixin(object):
         self._testRedirectDefault(301)
 
 
+    def test_redirect301Scheme(self):
+        """
+        L{client.RedirectAgent} follows cross-scheme redirects.
+        """
+        self._testRedirectDefault(
+            301,
+            crossScheme=True,
+        )
+
     def test_redirect302(self):
         """
         L{client.RedirectAgent} follows redirects on status code 302.
@@ -2712,6 +2778,48 @@ class _RedirectAgentTestsMixin(object):
         self._testRedirectDefault(307)
 
 
+    def test_headerSecurity(self):
+        """
+        L{client.RedirectAgent} scrubs sensitive headers when redirecting.
+        """
+        sensitiveHeaderValues = {
+            b"authorization": [b"sensitive-authnz"],
+            b"cookie": [b"sensitive-cookie-data"],
+            b"cookie2": [b"sensitive-cookie2-data"],
+            b"proxy-authorization": [b"sensitive-proxy-auth"],
+            b"wWw-auThentiCate": [b"sensitive-authn"],
+        }
+        otherHeaderValues = {b"x-random-header": [b"x-random-value"]}
+        allHeaders = Headers({**sensitiveHeaderValues, **otherHeaderValues})
+        redirected = self._testRedirectDefault(301, requestHeaders=allHeaders)
+
+        def normHeaders(headers: Headers) -> dict:
+            return {k.lower(): v for (k, v) in headers.getAllRawHeaders()}
+
+        sameOriginHeaders = normHeaders(redirected.headers)
+        self.assertEquals(
+            sameOriginHeaders,
+            {
+                b"host": [b"example.com"],
+                **normHeaders(allHeaders),
+            },
+        )
+
+        redirectedElsewhere = self._testRedirectDefault(
+            301,
+            crossDomain=True,
+            requestHeaders=Headers({**sensitiveHeaderValues, **otherHeaderValues}),
+        )
+        otherOriginHeaders = normHeaders(redirectedElsewhere.headers)
+        self.assertEquals(
+            otherOriginHeaders,
+            {
+                b"host": [b"example.com"],
+                **normHeaders(Headers(otherHeaderValues)),
+            },
+        )
+
+
     def _testRedirectToGet(self, code, method):
         """
         L{client.RedirectAgent} changes the method to I{GET} when getting
